<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mosaic Remover & Video Enhancer Pro (Stable)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- FFmpeg for transcoding (Version 0.11.0) -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.0/dist/ffmpeg.min.js"></script>
    
    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="favicon.ico">
    
    <style>
        body {
            background-color: #0f172a;
            color: #e2e8f0;
            font-family: 'Prompt', 'Segoe UI', sans-serif;
            overscroll-behavior: none;
        }
        .canvas-wrapper {
            width: 100%;
            height: 45vh;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }
        canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        /* Custom UI Elements */
        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -7px;
            border: 2px solid #1e293b;
            box-shadow: 0 0 5px rgba(59, 130, 246, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #475569;
            border-radius: 2px;
        }
        .ai-glow {
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from { box-shadow: 0 0 5px #3b82f6, 0 0 10px #3b82f6; }
            to { box-shadow: 0 0 10px #8b5cf6, 0 0 20px #8b5cf6; }
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="h-14 bg-slate-900 flex items-center justify-between px-4 border-b border-slate-700 shadow-lg z-10">
        <div class="flex items-center gap-2">
            <img src="Gemini_Generated_Image_l56orpl56orpl56o (3).jpg" class="w-8 h-8 rounded-full border-2 border-blue-500" alt="Icon">
            <h1 class="text-sm font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">Mosaic Remover AI</h1>
        </div>
        <div class="flex gap-2">
            <button onclick="document.getElementById('apiKeyModal').classList.remove('hidden')" class="text-xs text-slate-400 hover:text-white border border-slate-600 px-2 py-1 rounded">
                üîë API Key
            </button>
            <button id="uploadBtn" class="bg-slate-700 hover:bg-slate-600 text-white text-xs px-3 py-1.5 rounded-full flex items-center gap-2 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                Upload
            </button>
        </div>
        <input type="file" id="videoInput" accept="video/*" class="hidden">
    </header>

    <!-- Canvas Area -->
    <div class="canvas-wrapper">
        <p id="placeholderText" class="absolute text-slate-500 text-sm flex flex-col items-center gap-2">
            <span>‡πÅ‡∏ï‡∏∞ Upload ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠</span>
            <span class="text-xs opacity-50">(‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö MP4, WebM, MOV)</span>
        </p>
        <canvas id="videoCanvas"></canvas>
        
        <!-- Status Overlays -->
        <div id="processingOverlay" class="hidden absolute inset-0 bg-black/80 z-20 flex flex-col items-center justify-center p-6 text-center">
            <div class="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
            <h3 class="text-white font-bold text-lg mb-1">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</h3>
            <p id="progressText" class="text-slate-300 text-xs">‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà</p>
        </div>

        <div id="aiOverlay" class="hidden absolute inset-0 bg-black/80 z-20 flex flex-col items-center justify-center p-6 text-center">
            <div class="text-4xl mb-4 animate-bounce">‚ú®</div>
            <h3 class="text-white font-bold text-lg mb-1 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">Gemini ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå...</h3>
            <p class="text-slate-300 text-xs">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏™‡∏á ‡∏™‡∏µ ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏°‡∏ä‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡πÄ‡∏ü‡∏£‡∏°</p>
        </div>
        
        <div id="recordingBadge" class="hidden absolute top-4 right-4 flex items-center gap-2 bg-red-500/90 text-white text-[10px] font-bold px-3 py-1 rounded-full animate-pulse shadow-lg">
            <div class="w-2 h-2 bg-white rounded-full"></div> REC
        </div>
    </div>

    <!-- Controls -->
    <main class="flex-1 glass-panel overflow-y-auto pb-safe">
        <div class="p-4 space-y-5">
            
            <!-- AI Section -->
            <button id="aiEnhanceBtn" class="w-full bg-gradient-to-r from-indigo-900 to-purple-900 border border-purple-500/30 hover:border-purple-400 text-white py-3 rounded-xl flex items-center justify-center gap-2 transition-all shadow-lg relative overflow-hidden group">
                <div class="absolute inset-0 bg-white/5 group-hover:bg-white/10 transition-colors"></div>
                <span class="text-xl">‚ú®</span>
                <div class="text-left">
                    <div class="text-sm font-bold text-purple-200">AI Magic Analyze</div>
                    <div class="text-[10px] text-purple-300/70">‡πÉ‡∏´‡πâ Gemini ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</div>
                </div>
            </button>

            <!-- Filters Section -->
            <div class="bg-slate-800/50 p-3 rounded-xl border border-slate-700/50">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-xs font-bold text-slate-400 uppercase tracking-wider">Manual Adjustment</h3>
                    <label class="flex items-center gap-2 cursor-pointer">
                        <span class="text-[10px] text-blue-300">Unmosaic Mode</span>
                        <input type="checkbox" id="unmosaicMode" class="w-4 h-4 accent-blue-500">
                    </label>
                </div>

                <div class="space-y-4">
                    <!-- Contrast -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs text-slate-300">Contrast (‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏°‡∏ä‡∏±‡∏î)</label>
                            <span id="contrastVal" class="text-[10px] text-blue-400">110%</span>
                        </div>
                        <input type="range" id="contrast" min="100" max="250" value="110">
                    </div>

                    <!-- Brightness -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs text-slate-300">Brightness (‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á)</label>
                            <span id="brightnessVal" class="text-[10px] text-blue-400">105%</span>
                        </div>
                        <input type="range" id="brightness" min="80" max="150" value="105">
                    </div>

                    <!-- Saturate -->
                    <div>
                        <div class="flex justify-between mb-1">
                            <label class="text-xs text-slate-300">Saturation (‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏î)</label>
                            <span id="saturateVal" class="text-[10px] text-blue-400">120%</span>
                        </div>
                        <input type="range" id="saturate" min="0" max="200" value="120">
                    </div>
                </div>
            </div>

            <!-- Export Section -->
            <div class="space-y-3">
                <div class="flex gap-2">
                    <select id="formatSelect" class="bg-slate-800 text-white text-xs px-3 py-2 rounded-lg border border-slate-600 outline-none focus:border-blue-500 flex-1">
                        <option value="webm">WebM (‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ - ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏∏‡∏Å‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á)</option>
                        <option value="mp4" id="mp4Option">MP4 (‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö)</option>
                        <option value="avi" id="aviOption">AVI (‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö)</option>
                    </select>
                    <button id="playBtn" disabled class="flex-1 bg-slate-700 disabled:opacity-50 text-white py-2 rounded-lg text-sm font-medium">
                        Play/Pause
                    </button>
                </div>

                <!-- Warning Message for SharedArrayBuffer -->
                <div id="compatibilityWarning" class="hidden bg-yellow-900/30 border border-yellow-700/50 p-2 rounded-lg">
                    <p class="text-[10px] text-yellow-200 text-center">
                        ‚ö†Ô∏è Browser ‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á MP4 (Security restriction).<br>
                        ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô <b>WebM</b> ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (‡πÄ‡∏õ‡∏¥‡∏î‡∏î‡∏π‡πÑ‡∏î‡πâ‡∏õ‡∏Å‡∏ï‡∏¥)
                    </p>
                </div>

                <button id="exportBtn" disabled class="w-full bg-gradient-to-r from-blue-600 to-indigo-600 disabled:opacity-50 text-white py-3.5 rounded-xl text-sm font-bold shadow-lg shadow-blue-900/40 flex items-center justify-center gap-2">
                    <span>Start Processing & Save</span>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" /></svg>
                </button>
            </div>
        </div>
    </main>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/90 p-4">
        <div class="bg-slate-800 rounded-xl p-6 w-full max-w-sm border border-slate-700">
            <h3 class="text-white font-bold text-lg mb-2">Gemini API Key</h3>
            <p class="text-slate-400 text-xs mb-4">‡πÉ‡∏™‡πà API Key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏ü‡∏µ‡πÄ‡∏à‡∏≠‡∏£‡πå AI Auto-Enhance (‡∏£‡∏±‡∏ö‡∏ü‡∏£‡∏µ‡∏ó‡∏µ‡πà aistudio.google.com)</p>
            <input type="password" id="apiKeyInput" placeholder="Paste API Key here..." class="w-full bg-slate-900 text-white p-3 rounded-lg border border-slate-600 mb-4 text-sm focus:border-blue-500 outline-none">
            <div class="flex justify-end gap-2">
                <button onclick="document.getElementById('apiKeyModal').classList.add('hidden')" class="px-4 py-2 text-slate-300 text-sm">Cancel</button>
                <button onclick="saveApiKey()" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold">Save</button>
            </div>
        </div>
    </div>

    <!-- Hidden Video Source -->
    <video id="sourceVideo" class="hidden" playsinline crossorigin="anonymous"></video>

    <script>
        // --- Variables ---
        const { createFFmpeg, fetchFile } = FFmpeg;
        let ffmpeg = null;
        let ffmpegSupported = false;
        
        const videoInput = document.getElementById('videoInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const sourceVideo = document.getElementById('sourceVideo');
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const playBtn = document.getElementById('playBtn');
        const exportBtn = document.getElementById('exportBtn');
        const processingOverlay = document.getElementById('processingOverlay');
        const aiOverlay = document.getElementById('aiOverlay');
        const progressText = document.getElementById('progressText');
        const formatSelect = document.getElementById('formatSelect');
        const unmosaicMode = document.getElementById('unmosaicMode');
        const aiEnhanceBtn = document.getElementById('aiEnhanceBtn');
        const compatibilityWarning = document.getElementById('compatibilityWarning');

        let isPlaying = false;
        let isRecording = false;
        let mediaRecorder;
        let recordedChunks = [];
        let animationId;
        
        // Filters
        const filters = {
            contrast: document.getElementById('contrast'),
            brightness: document.getElementById('brightness'),
            saturate: document.getElementById('saturate')
        };
        const filterVals = {
            contrast: document.getElementById('contrastVal'),
            brightness: document.getElementById('brightnessVal'),
            saturate: document.getElementById('saturateVal')
        };

        // --- Initialization & Compatibility Check ---
        
        function checkCompatibility() {
            // Check for SharedArrayBuffer support (Required for FFmpeg MP4 conversion)
            if (typeof SharedArrayBuffer === 'undefined') {
                console.warn('SharedArrayBuffer is NOT supported. Disabling MP4 transcoding.');
                ffmpegSupported = false;
                
                // Show warning UI
                compatibilityWarning.classList.remove('hidden');
                
                // Disable incompatible options
                document.getElementById('mp4Option').disabled = true;
                document.getElementById('mp4Option').text += " (Not Supported)";
                document.getElementById('aviOption').disabled = true;
                document.getElementById('aviOption').text += " (Not Supported)";
                
                // Force WebM
                formatSelect.value = 'webm';
                formatSelect.disabled = true;
            } else {
                ffmpegSupported = true;
            }
        }
        
        // Run check on load
        checkCompatibility();

        const initFFmpeg = async () => {
            if (!ffmpegSupported) return false;
            
            if (ffmpeg === null) {
                try {
                    ffmpeg = createFFmpeg({ log: true });
                    await ffmpeg.load();
                    return true;
                } catch (e) {
                    console.error("FFmpeg Load Error:", e);
                    alert("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÑ‡∏î‡πâ (Error: " + e.message + ")\n‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô WebM ‡πÅ‡∏ó‡∏ô");
                    ffmpegSupported = false;
                    formatSelect.value = 'webm';
                    formatSelect.disabled = true;
                    return false;
                }
            }
            return true;
        };

        // Load API Key
        let geminiApiKey = localStorage.getItem('gemini_api_key') || '';
        if(geminiApiKey) document.getElementById('apiKeyInput').value = geminiApiKey;

        function saveApiKey() {
            const key = document.getElementById('apiKeyInput').value.trim();
            if(key) {
                geminiApiKey = key;
                localStorage.setItem('gemini_api_key', key);
                document.getElementById('apiKeyModal').classList.add('hidden');
                alert('API Key saved!');
            }
        }

        // --- Event Listeners ---
        
        uploadBtn.addEventListener('click', () => videoInput.click());
        
        videoInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            sourceVideo.src = url;
            
            sourceVideo.onloadedmetadata = () => {
                canvas.width = sourceVideo.videoWidth;
                canvas.height = sourceVideo.videoHeight;
                
                document.getElementById('placeholderText').style.display = 'none';
                playBtn.disabled = false;
                exportBtn.disabled = false;
                
                resetFilters();
                drawFrame();
            };
        });

        playBtn.addEventListener('click', () => {
            if (sourceVideo.paused) {
                sourceVideo.play();
                isPlaying = true;
                drawLoop();
            } else {
                sourceVideo.pause();
                isPlaying = false;
                cancelAnimationFrame(animationId);
            }
        });

        // Filter UI Updates
        Object.keys(filters).forEach(key => {
            filters[key].addEventListener('input', (e) => {
                filterVals[key].textContent = e.target.value + '%';
                if (!isPlaying) requestAnimationFrame(drawFrame);
            });
        });

        // Unmosaic Preset
        unmosaicMode.addEventListener('change', (e) => {
            if(e.target.checked) {
                setFilters(140, 110, 130);
            } else {
                resetFilters();
            }
            if (!isPlaying) requestAnimationFrame(drawFrame);
        });

        function resetFilters() {
            setFilters(110, 105, 120);
        }

        function setFilters(c, b, s) {
            filters.contrast.value = c;
            filters.brightness.value = b;
            filters.saturate.value = s;
            updateFilterLabels();
        }

        function updateFilterLabels() {
            filterVals.contrast.textContent = filters.contrast.value + '%';
            filterVals.brightness.textContent = filters.brightness.value + '%';
            filterVals.saturate.textContent = filters.saturate.value + '%';
        }

        // --- GEMINI AI Logic ---

        aiEnhanceBtn.addEventListener('click', async () => {
            if (!sourceVideo.src || sourceVideo.src === '') {
                alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö');
                return;
            }
            if (!geminiApiKey) {
                document.getElementById('apiKeyModal').classList.remove('hidden');
                return;
            }

            aiOverlay.classList.remove('hidden');
            
            try {
                // 1. Capture current frame
                const frameData = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];

                // 2. Prepare API Call
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${geminiApiKey}`;
                
                const prompt = `
                    You are a professional video restoration expert. Analyze this image frame. It might be low quality, blurry, or have mosaic artifacts. 
                    Suggest the best CSS filter values to make it look as clear, sharp, and vivid as possible.
                    
                    Return ONLY a JSON object with these integer properties:
                    - contrast (range 100-200, default is 110)
                    - brightness (range 80-150, default is 105)
                    - saturate (range 100-200, default is 120)
                    
                    Example response: {"contrast": 135, "brightness": 95, "saturate": 140}
                `;

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [
                                { text: prompt },
                                { inlineData: { mimeType: "image/jpeg", data: frameData } }
                            ]
                        }],
                        generationConfig: {
                            responseMimeType: "application/json"
                        }
                    })
                });

                const data = await response.json();
                
                if (data.error) throw new Error(data.error.message);
                
                const suggestion = JSON.parse(data.candidates[0].content.parts[0].text);
                
                setFilters(suggestion.contrast, suggestion.brightness, suggestion.saturate);
                unmosaicMode.checked = false;
                
                alert(`‚ú® Gemini Analyzed!\nContrast: ${suggestion.contrast}%\nBrightness: ${suggestion.brightness}%\nSaturate: ${suggestion.saturate}%`);
                
                if (!isPlaying) requestAnimationFrame(drawFrame);

            } catch (error) {
                console.error(error);
                alert('AI Error: ' + error.message);
            } finally {
                aiOverlay.classList.add('hidden');
            }
        });


        // --- Drawing Logic ---

        function drawFrame() {
            const filterString = `contrast(${filters.contrast.value}%) brightness(${filters.brightness.value}%) saturate(${filters.saturate.value}%)`;
            ctx.filter = filterString;
            ctx.drawImage(sourceVideo, 0, 0, canvas.width, canvas.height);
        }

        function drawLoop() {
            drawFrame();
            if (!sourceVideo.paused && !sourceVideo.ended) {
                animationId = requestAnimationFrame(drawLoop);
            }
        }

        // --- Recording & Export Logic ---

        exportBtn.addEventListener('click', async () => {
            if (isRecording) {
                stopRecording();
            } else {
                const format = formatSelect.value;
                
                // If user selected MP4 but it's not actually supported (bypass disable via inspect), force WebM
                if (format !== 'webm' && !ffmpegSupported) {
                    alert("‡∏£‡∏∞‡∏ö‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á MP4 ‡∏à‡∏∂‡∏á‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô WebM ‡πÅ‡∏ó‡∏ô");
                    formatSelect.value = 'webm';
                }

                if (format !== 'webm' && ffmpegSupported) {
                     if(!confirm(`‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô ${format.toUpperCase()} ‡∏≠‡∏≤‡∏à‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏≤‡∏ô‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ (2-3 ‡∏ô‡∏≤‡∏ó‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏•‡∏¥‡∏õ‡∏™‡∏±‡πâ‡∏ô)\n\n‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ó‡∏≥‡∏ï‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?`)) {
                         return;
                     }
                     processingOverlay.classList.remove('hidden');
                     progressText.textContent = 'Loading Transcoder Engine...';
                     
                     const loaded = await initFFmpeg();
                     if (!loaded) {
                         processingOverlay.classList.add('hidden');
                         return; 
                     }
                     processingOverlay.classList.add('hidden');
                }
                
                startRecording();
            }
        });

        function startRecording() {
            recordedChunks = [];
            const stream = canvas.captureStream(30); 
            
            let options = { mimeType: 'video/webm;codecs=vp9' };
            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                options = { mimeType: 'video/webm;codecs=vp8' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'video/webm' };
                }
            }

            mediaRecorder = new MediaRecorder(stream, options);

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = processAndDownload;

            sourceVideo.currentTime = 0;
            sourceVideo.play();
            drawLoop();
            mediaRecorder.start();

            isRecording = true;
            exportBtn.innerHTML = '<span class="animate-pulse">Stop & Save</span>';
            exportBtn.classList.add('bg-red-600', 'from-red-600', 'to-red-700');
            exportBtn.classList.remove('from-blue-600', 'to-indigo-600');
            document.getElementById('recordingBadge').classList.remove('hidden');
            
            formatSelect.disabled = true;
            videoInput.disabled = true;
        }

        function stopRecording() {
            mediaRecorder.stop();
            sourceVideo.pause();
            cancelAnimationFrame(animationId);
            
            isRecording = false;
            exportBtn.innerHTML = '<span>Start Processing & Save</span>';
            exportBtn.classList.remove('bg-red-600', 'from-red-600', 'to-red-700');
            exportBtn.classList.add('from-blue-600', 'to-indigo-600');
            document.getElementById('recordingBadge').classList.add('hidden');
        }

        async function processAndDownload() {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const targetFormat = formatSelect.value;

            if (targetFormat === 'webm' || !ffmpegSupported) {
                downloadBlob(blob, `enhanced_${Date.now()}.webm`);
                resetUI();
            } else {
                await transcodeVideo(blob, targetFormat);
            }
        }

        async function transcodeVideo(webmBlob, format) {
            processingOverlay.classList.remove('hidden');
            progressText.textContent = `Preparing conversion to ${format.toUpperCase()}...`;

            try {
                // Double check load
                if (!ffmpeg.isLoaded()) await ffmpeg.load();

                const inputName = 'input.webm';
                const outputName = `output.${format}`;

                ffmpeg.FS('writeFile', inputName, await fetchFile(webmBlob));
                progressText.textContent = `Converting to ${format}... (Processing)`;
                
                // Use fallback copy if possible for speed, or re-encode if AVI
                if(format === 'mp4') {
                     await ffmpeg.run('-i', inputName, '-c:v', 'copy', outputName);
                } else {
                     await ffmpeg.run('-i', inputName, outputName);
                }

                const data = ffmpeg.FS('readFile', outputName);
                const newBlob = new Blob([data.buffer], { type: `video/${format}` });
                downloadBlob(newBlob, `enhanced_${Date.now()}.${format}`);

                ffmpeg.FS('unlink', inputName);
                ffmpeg.FS('unlink', outputName);

            } catch (error) {
                console.error(error);
                alert(`Error during conversion: ${error.message}\nSaved as WebM instead.`);
                downloadBlob(webmBlob, `enhanced_fallback_${Date.now()}.webm`);
            } finally {
                processingOverlay.classList.add('hidden');
                resetUI();
            }
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        }

        function resetUI() {
            // Restore UI state based on compatibility
            if(ffmpegSupported) {
                formatSelect.disabled = false;
            } else {
                formatSelect.disabled = true; // Stay disabled/locked to WebM
            }
            videoInput.disabled = false;
            sourceVideo.currentTime = 0;
            drawFrame();
        }
    </script>
</body>
</html>
